---
description: React and TypeScript coding standards and best practices
globs: ['**/*.tsx', '**/*.ts']
alwaysApply: true
---

# React & TypeScript Rules

## Component Patterns

- **Always use functional components** - Never use class components
- **Use named exports** for components and utilities (e.g., `export function ComponentName`)
- **Prefer interfaces over types** for object shapes and component props
- **Use early returns** in functions to reduce nesting and improve readability
- **Keep components focused** - Each component should have a single responsibility

## TypeScript Guidelines

- Use TypeScript for all code - no `.js` or `.jsx` files
- Define interfaces for all component props
- Use type inference where appropriate, but be explicit for public APIs
- Avoid `any` type - use `unknown` or proper types instead
- Use literal types or maps instead of enums
- Leverage TypeScript's strict mode features

## Naming Conventions

- **Components**: PascalCase (e.g., `UserProfile`, `NavigationMenu`)
- **Functions/Variables**: camelCase (e.g., `getUserData`, `isLoading`)
- **Event Handlers**: Prefix with `handle` (e.g., `handleClick`, `handleSubmit`)
- **Boolean variables**: Use auxiliary verbs (e.g., `isLoading`, `hasError`, `canEdit`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_RETRIES`, `API_BASE_URL`)

## React Hooks

- Use hooks at the top level of components, never inside loops or conditions
- Extract custom hooks for reusable logic
- Use `useCallback` for functions passed as props to memoized components
- Use `useMemo` for expensive computations
- Use `useRef` for mutable values that don't trigger re-renders

## Component Structure

Organize component files in this order:
1. Imports (React, third-party, local)
2. Types/Interfaces
3. Constants
4. Main component
5. Subcomponents (if any)
6. Helper functions
7. Exports

Example structure:
```tsx
import React, { useState, useEffect } from 'react';
import { SomeLibrary } from 'some-library';

interface ComponentProps {
  title: string;
  onAction: () => void;
}

const CONSTANT_VALUE = 'value';

export function ComponentName({ title, onAction }: ComponentProps) {
  const [state, setState] = useState<string>('');
  
  useEffect(() => {
    // effect logic
  }, []);

  const handleClick = () => {
    // handler logic
  };

  return (
    <div>
      {/* component JSX */}
    </div>
  );
}
```

## Props and State

- Destructure props in the function signature
- Use descriptive prop names
- Provide default values using default parameters when appropriate
- Use TypeScript to enforce required vs optional props
- Keep state local when possible, lift only when necessary

## Performance

- Use `React.memo` for components that receive stable props
- Memoize expensive calculations with `useMemo`
- Memoize callbacks with `useCallback` when passing to memoized children
- Avoid creating objects/arrays in render - move to state or useMemo

## Error Handling

- Use error boundaries for component-level error handling
- Handle async errors with try/catch or `.catch()`
- Provide meaningful error messages to users
- Log errors appropriately for debugging

## Accessibility

- Use semantic HTML elements
- Include `aria-label` for icon-only buttons
- Ensure keyboard navigation works
- Use proper heading hierarchy (h1, h2, h3, etc.)
- Include `alt` text for images
- Use `tabindex` appropriately (usually avoid unless necessary)
